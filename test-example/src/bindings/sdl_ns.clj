;; This file is autogenerated -- probably shouldn't modify it by hand
(clojure.core/ns
 bindings.sdl-ns
 (:require [clojure.java.io])
 (:import
  org.graalvm.polyglot.Context
  org.graalvm.polyglot.Source
  org.graalvm.polyglot.Value)
 (:gen-class))

(def ^{:private true} empty-array (clojure.core/object-array 0))

(clojure.core/defn
 context-f
 []
 (clojure.core/->
  (org.graalvm.polyglot.Context/newBuilder
   (clojure.core/into-array ["llvm"]))
  (.allowAllAccess true)
  (.build)))

(clojure.core/defn
 ^{:private true}
 source-f
 []
 (clojure.core/->
  (org.graalvm.polyglot.Source/newBuilder
   "llvm"
   (if
    (clojure.core/string? "libs/libbindings$sdl.so")
    (clojure.java.io/file "libs/libbindings$sdl.so")
    "libs/libbindings$sdl.so"))
  (.build)))

(def polyglot-context (context-f))

(def polyglot-lib (.eval polyglot-context (source-f)))

(clojure.core/gen-interface
 :name
 ^{org.graalvm.polyglot.HostAccess$Implementable true}
 bindings.sdl_structs.ISDL_Event
 :methods
 [[type [] int]
  [set_type [int] void]
  [key [] bindings.sdl_structs.ISDL_KeyboardEvent]
  [set_key [bindings.sdl_structs.ISDL_KeyboardEvent] void]])

(clojure.core/gen-interface
 :name
 ^{org.graalvm.polyglot.HostAccess$Implementable true}
 bindings.sdl_structs.ISDL_KeyboardEvent
 :methods
 [[keysym [] bindings.sdl_structs.ISDL_Keysym]
  [set_keysym [bindings.sdl_structs.ISDL_Keysym] void]])

(clojure.core/gen-interface
 :name
 ^{org.graalvm.polyglot.HostAccess$Implementable true}
 bindings.sdl_structs.ISDL_Keysym
 :methods
 [[sym [] int] [set_sym [int] void]])

(clojure.core/gen-interface
 :name
 ^{org.graalvm.polyglot.HostAccess$Implementable true}
 bindings.sdl_structs.ISDL_Surface
 :methods
 [[format [] bindings.sdl_structs.ISDL_PixelFormat]
  [set_format [bindings.sdl_structs.ISDL_PixelFormat] void]])

(clojure.core/gen-interface
 :name
 ^{org.graalvm.polyglot.HostAccess$Implementable true}
 bindings.sdl_structs.ISDL_PixelFormat
 :methods
 [[palette [] clobits.all_targets.IVoidPointerYE]
  [set_palette [clobits.all_targets.IVoidPointerYE] void]])

(clojure.core/gen-interface
 :name
 ^{org.graalvm.polyglot.HostAccess$Implementable true}
 bindings.sdl_structs.ISDL_Rect
 :methods
 [[x [] int]
  [set_x [int] void]
  [y [] int]
  [set_y [int] void]
  [w [] int]
  [set_w [int] void]
  [h [] int]
  [set_h [int] void]])

(clojure.core/declare
 wrap-sdl-event
 wrap-sdl-rect
 wrap-pointer
 wrap-sdl-pixel-format
 wrap-sdl-surface
 wrap-sdl-keysym
 wrap-sdl-keyboard-event)

(clojure.core/defn
 wrap-sdl-event
 [value]
 (clojure.core/reify
  bindings.sdl_structs.ISDL_Event
  (type [_] (clojure.core/-> (.getMember value "type") .asInt))
  (set_type [_ v] (.putMember value "type" v))
  (key [_] (wrap-sdl-keyboard-event (.getMember value "key")))
  (set_key [_ v] (.putMember value "key" (.unwrap v)))
  clobits.all_targets.IWrapper
  (unwrap [_] (.as value bindings.sdl_structs.ISDL_Event))))

(clojure.core/defn
 wrap-sdl-keyboard-event
 [value]
 (clojure.core/reify
  bindings.sdl_structs.ISDL_KeyboardEvent
  (keysym [_] (wrap-sdl-keysym (.getMember value "keysym")))
  (set_keysym [_ v] (.putMember value "keysym" (.unwrap v)))
  clobits.all_targets.IWrapper
  (unwrap [_] (.as value bindings.sdl_structs.ISDL_KeyboardEvent))))

(clojure.core/defn
 wrap-sdl-keysym
 [value]
 (clojure.core/reify
  bindings.sdl_structs.ISDL_Keysym
  (sym [_] (clojure.core/-> (.getMember value "sym") .asInt))
  (set_sym [_ v] (.putMember value "sym" v))
  clobits.all_targets.IWrapper
  (unwrap [_] (.as value bindings.sdl_structs.ISDL_Keysym))))

(clojure.core/defn
 wrap-sdl-surface
 [value]
 (clojure.core/reify
  bindings.sdl_structs.ISDL_Surface
  (format [_] (wrap-sdl-pixel-format (.getMember value "format")))
  (set_format [_ v] (.putMember value "format" (.unwrap v)))
  clobits.all_targets.IWrapper
  (unwrap [_] (.as value bindings.sdl_structs.ISDL_Surface))))

(clojure.core/defn
 wrap-sdl-pixel-format
 [value]
 (clojure.core/reify
  bindings.sdl_structs.ISDL_PixelFormat
  (palette [_] (wrap-pointer (.getMember value "palette")))
  (set_palette [_ v] (.putMember value "palette" (.unwrap v)))
  clobits.all_targets.IWrapper
  (unwrap [_] (.as value bindings.sdl_structs.ISDL_PixelFormat))))

(clojure.core/defn
 wrap-sdl-rect
 [value]
 (clojure.core/reify
  bindings.sdl_structs.ISDL_Rect
  (x [_] (clojure.core/-> (.getMember value "x") .asInt))
  (set_x [_ v] (.putMember value "x" v))
  (y [_] (clojure.core/-> (.getMember value "y") .asInt))
  (set_y [_ v] (.putMember value "y" v))
  (w [_] (clojure.core/-> (.getMember value "w") .asInt))
  (set_w [_ v] (.putMember value "w" v))
  (h [_] (clojure.core/-> (.getMember value "h") .asInt))
  (set_h [_ v] (.putMember value "h" v))
  clobits.all_targets.IWrapper
  (unwrap [_] (.as value bindings.sdl_structs.ISDL_Rect))))

(clojure.core/defn
 wrap-pointer
 [value]
 (clojure.core/reify clobits.all_targets.IWrapper (unwrap [_] value)))

(def
 ^{:private true}
 -place-of-get-sdl-init-video
 (.getMember polyglot-lib "_SHADOWING_GET_SDL_INIT_VIDEO"))

(clojure.core/defn
 get-sdl-init-video
 "Args:[], Ret: {:ni/wrapper {:type int, :convert int}, :poly/wrapper {:convert .asInt}, :poly/type int, :primitive true}"
 ^long
 []
 (clojure.core/->
  (.execute
   -place-of-get-sdl-init-video
   (clojure.core/object-array []))
  .asInt))

(def
 ^{:private true}
 -place-of-get-sdl-window-shown
 (.getMember polyglot-lib "_SHADOWING_GET_SDL_WINDOW_SHOWN"))

(clojure.core/defn
 get-sdl-window-shown
 "Args:[], Ret: {:ni/wrapper {:type int, :convert int}, :poly/wrapper {:convert .asInt}, :poly/type int, :primitive true}"
 ^long
 []
 (clojure.core/->
  (.execute
   -place-of-get-sdl-window-shown
   (clojure.core/object-array []))
  .asInt))

(def
 ^{:private true}
 -place-of-get-null
 (.getMember polyglot-lib "_SHADOWING_get_null"))

(clojure.core/defn
 get-null
 "Args:[], Ret: {\"*\" {:poly/type clobits.all_targets.IVoidPointerYE, :ni/type clobits.all_targets.IVoidPointer, :ni/wrapper {:convert clobits.wrappers.WrapVoid}, :ni/unwrap .unwrap, :poly/wrapper {:convert wrap-pointer}, :poly/unwrap .unwrap, :primitive false}, :ni/type clobits.all_targets.IVoidPointer, :primitive false, :poly/type clobits.all_targets.IVoidPointerYE, :ni/wrapper {:convert clobits.wrappers.WrapVoid}, :ni/unwrap .unwrap, :poly/wrapper {:convert wrap-pointer}, :poly/unwrap .unwrap}"
 ^clobits.all_targets.IVoidPointerYE
 []
 (clojure.core/->
  (.executeVoid -place-of-get-null (clojure.core/object-array []))
  wrap-pointer))

(def
 ^{:private true}
 -place-of-gen-title
 (.getMember polyglot-lib "_SHADOWING_gen_title"))

(clojure.core/defn
 gen-title
 "Args:[], Ret: {\"*\" {:ni/type org.graalvm.nativeimage.c.type.CCharPointer, :poly/type nil, :primitive false}, :poly/type nil, :ni/type org.graalvm.nativeimage.c.type.CCharPointer, :primitive false}"
 
 []
 (.execute -place-of-gen-title (clojure.core/object-array [])))

(def
 ^{:private true}
 -place-of-create-rect
 (.getMember polyglot-lib "_SHADOWING_create_rect"))

(clojure.core/defn
 create-rect
 "Args:[{:ni/wrapper {:type int, :convert int}, :poly/wrapper {:convert .asInt}, :poly/type int, :primitive true, :annotation long, :arg-symbol x} {:ni/wrapper {:type int, :convert int}, :poly/wrapper {:convert .asInt}, :poly/type int, :primitive true, :annotation long, :arg-symbol y} {:ni/wrapper {:type int, :convert int}, :poly/wrapper {:convert .asInt}, :poly/type int, :primitive true, :annotation long, :arg-symbol w} {:ni/wrapper {:type int, :convert int}, :poly/wrapper {:convert .asInt}, :poly/type int, :primitive true, :annotation long, :arg-symbol h}], Ret: {:interface bindings.sdl_structs.ISDL_Rect, :c-sym \"SDL_Rect\", :ni/interface bindings.sdl.ni.ISDL_Rect, :ni/wrapper {:convert bindings.sdl.ni.SDL_Rect., :type bindings.sdl.ni.SDL_Rect}, :poly/type bindings.sdl_structs.ISDL_Rect, :poly/unwrap .unwrap, :primitive false, :poly/wrapper {:convert wrap-sdl-rect}, :ni/unwrap .unwrap}"
 ^bindings.sdl_structs.ISDL_Rect
 [^long x ^long y ^long w ^long h]
 (clojure.core/->
  (.execute
   -place-of-create-rect
   (clojure.core/object-array [x y w h]))
  wrap-sdl-rect))

(def
 ^{:private true}
 -place-of-get-e
 (.getMember polyglot-lib "_SHADOWING_get_e"))

(clojure.core/defn
 get-e
 "Args:[], Ret: {:interface bindings.sdl_structs.ISDL_Event, :c-sym \"SDL_Event\", :ni/interface bindings.sdl.ni.ISDL_Event, :ni/wrapper {:convert bindings.sdl.ni.SDL_Event., :type bindings.sdl.ni.SDL_Event}, :poly/type bindings.sdl_structs.ISDL_Event, :poly/unwrap .unwrap, :primitive false, :poly/wrapper {:convert wrap-sdl-event}, :ni/unwrap .unwrap}"
 ^bindings.sdl_structs.ISDL_Event
 []
 (clojure.core/->
  (.execute -place-of-get-e (clojure.core/object-array []))
  wrap-sdl-event))

(def
 ^{:private true}
 -place-of-init
 (.getMember polyglot-lib "_SHADOWING_SDL_Init"))

(clojure.core/defn
 init
 "Args:[{:ni/wrapper {:type int, :convert int}, :poly/wrapper {:convert .asInt}, :poly/type int, :primitive true, :annotation long, :arg-symbol flags}], Ret: {:ni/wrapper {:type int, :convert int}, :poly/wrapper {:convert .asInt}, :poly/type int, :primitive true}"
 ^long
 [^long flags]
 (clojure.core/->
  (.execute -place-of-init (clojure.core/object-array [flags]))
  .asInt))

(def
 ^{:private true}
 -place-of-poll-event
 (.getMember polyglot-lib "_SHADOWING_SDL_PollEvent"))

(clojure.core/defn
 poll-event
 "Args:[{:interface bindings.sdl_structs.ISDL_Event, :c-sym \"SDL_Event\", :ni/interface bindings.sdl.ni.ISDL_Event, :ni/wrapper {:convert bindings.sdl.ni.SDL_Event., :type bindings.sdl.ni.SDL_Event}, :poly/type bindings.sdl_structs.ISDL_Event, :poly/unwrap .unwrap, :primitive false, :arg-symbol event, :poly/wrapper {:convert wrap-sdl-event}, :annotation bindings.sdl_structs.ISDL_Event, :ni/unwrap .unwrap}], Ret: {:ni/wrapper {:type int, :convert int}, :poly/wrapper {:convert .asInt}, :poly/type int, :primitive true}"
 ^long
 [^bindings.sdl_structs.ISDL_Event event]
 (clojure.core/->
  (.execute
   -place-of-poll-event
   (clojure.core/object-array [(.unwrap event)]))
  .asInt))

(def
 ^{:private true}
 -place-of-delay
 (.getMember polyglot-lib "_SHADOWING_SDL_Delay"))

(clojure.core/defn
 delay
 "Args:[{:ni/wrapper {:type int, :convert int}, :poly/wrapper {:convert .asInt}, :poly/type int, :primitive true, :annotation long, :arg-symbol ms}], Ret: {\"*\" {:poly/type clobits.all_targets.IVoidPointerYE, :ni/type clobits.all_targets.IVoidPointer, :ni/wrapper {:convert clobits.wrappers.WrapVoid}, :ni/unwrap .unwrap, :poly/wrapper {:convert wrap-pointer}, :poly/unwrap .unwrap, :primitive false}, :ni/type void, :primitive true}"
 
 [^long ms]
 (.executeVoid -place-of-delay (clojure.core/object-array [ms])))

(def
 ^{:private true}
 -place-of-update-window-surface
 (.getMember polyglot-lib "_SHADOWING_SDL_UpdateWindowSurface"))

(clojure.core/defn
 update-window-surface
 "Args:[{\"*\" {:poly/type clobits.all_targets.IVoidPointerYE, :ni/type clobits.all_targets.IVoidPointer, :ni/wrapper {:convert clobits.wrappers.WrapVoid}, :ni/unwrap .unwrap, :poly/wrapper {:convert wrap-pointer}, :poly/unwrap .unwrap, :primitive false}, :ni/wrapper {:convert clobits.wrappers.WrapVoid}, :poly/type clobits.all_targets.IVoidPointerYE, :poly/unwrap .unwrap, :primitive false, :arg-symbol window, :ni/type clobits.all_targets.IVoidPointer, :poly/wrapper {:convert wrap-pointer}, :annotation clobits.all_targets.IVoidPointerYE, :ni/unwrap .unwrap}], Ret: {:ni/wrapper {:type int, :convert int}, :poly/wrapper {:convert .asInt}, :poly/type int, :primitive true}"
 ^long
 [^clobits.all_targets.IVoidPointerYE window]
 (clojure.core/->
  (.execute
   -place-of-update-window-surface
   (clojure.core/object-array [(.unwrap window)]))
  .asInt))

(def
 ^{:private true}
 -place-of-get-window-surface
 (.getMember polyglot-lib "_SHADOWING_SDL_GetWindowSurface"))

(clojure.core/defn
 get-window-surface
 "Args:[{\"*\" {:poly/type clobits.all_targets.IVoidPointerYE, :ni/type clobits.all_targets.IVoidPointer, :ni/wrapper {:convert clobits.wrappers.WrapVoid}, :ni/unwrap .unwrap, :poly/wrapper {:convert wrap-pointer}, :poly/unwrap .unwrap, :primitive false}, :ni/wrapper {:convert clobits.wrappers.WrapVoid}, :poly/type clobits.all_targets.IVoidPointerYE, :poly/unwrap .unwrap, :primitive false, :arg-symbol window, :ni/type clobits.all_targets.IVoidPointer, :poly/wrapper {:convert wrap-pointer}, :annotation clobits.all_targets.IVoidPointerYE, :ni/unwrap .unwrap}], Ret: {:interface bindings.sdl_structs.ISDL_Surface, :c-sym \"SDL_Surface\", :ni/interface bindings.sdl.ni.ISDL_Surface, :ni/wrapper {:convert bindings.sdl.ni.SDL_Surface., :type bindings.sdl.ni.SDL_Surface}, :poly/type bindings.sdl_structs.ISDL_Surface, :poly/unwrap .unwrap, :primitive false, :poly/wrapper {:convert wrap-sdl-surface}, :ni/unwrap .unwrap}"
 ^bindings.sdl_structs.ISDL_Surface
 [^clobits.all_targets.IVoidPointerYE window]
 (clojure.core/->
  (.execute
   -place-of-get-window-surface
   (clojure.core/object-array [(.unwrap window)]))
  wrap-sdl-surface))

(def
 ^{:private true}
 -place-of-map-rgb
 (.getMember polyglot-lib "_SHADOWING_SDL_MapRGB"))

(clojure.core/defn
 map-rgb
 "Args:[{:interface bindings.sdl_structs.ISDL_PixelFormat, :c-sym \"SDL_PixelFormat\", :ni/interface bindings.sdl.ni.ISDL_PixelFormat, :ni/wrapper {:convert bindings.sdl.ni.SDL_PixelFormat., :type bindings.sdl.ni.SDL_PixelFormat}, :poly/type bindings.sdl_structs.ISDL_PixelFormat, :poly/unwrap .unwrap, :primitive false, :arg-symbol format, :poly/wrapper {:convert wrap-sdl-pixelformat}, :annotation bindings.sdl_structs.ISDL_PixelFormat, :ni/unwrap .unwrap} {:ni/wrapper {:type int, :convert int}, :poly/wrapper {:convert .asInt}, :poly/type int, :primitive true, :annotation long, :arg-symbol r} {:ni/wrapper {:type int, :convert int}, :poly/wrapper {:convert .asInt}, :poly/type int, :primitive true, :annotation long, :arg-symbol g} {:ni/wrapper {:type int, :convert int}, :poly/wrapper {:convert .asInt}, :poly/type int, :primitive true, :annotation long, :arg-symbol b}], Ret: {:ni/wrapper {:type int, :convert int}, :poly/wrapper {:convert .asInt}, :poly/type int, :primitive true}"
 ^long
 [^bindings.sdl_structs.ISDL_PixelFormat
  format
  ^long
  r
  ^long
  g
  ^long
  b]
 (clojure.core/->
  (.execute
   -place-of-map-rgb
   (clojure.core/object-array [(.unwrap format) r g b]))
  .asInt))

(def
 ^{:private true}
 -place-of-create-window
 (.getMember polyglot-lib "_SHADOWING_SDL_CreateWindow"))

(clojure.core/defn
 create-window
 "Args:[{\"*\" {:ni/type org.graalvm.nativeimage.c.type.CCharPointer, :poly/type nil, :primitive false}, :poly/type nil, :ni/type org.graalvm.nativeimage.c.type.CCharPointer, :primitive false, :annotation nil, :arg-symbol title} {:ni/wrapper {:type int, :convert int}, :poly/wrapper {:convert .asInt}, :poly/type int, :primitive true, :annotation Long, :arg-symbol x} {:ni/wrapper {:type int, :convert int}, :poly/wrapper {:convert .asInt}, :poly/type int, :primitive true, :annotation Long, :arg-symbol y} {:ni/wrapper {:type int, :convert int}, :poly/wrapper {:convert .asInt}, :poly/type int, :primitive true, :annotation Long, :arg-symbol w} {:ni/wrapper {:type int, :convert int}, :poly/wrapper {:convert .asInt}, :poly/type int, :primitive true, :annotation Long, :arg-symbol h} {:ni/wrapper {:type int, :convert int}, :poly/wrapper {:convert .asInt}, :poly/type int, :primitive true, :annotation Long, :arg-symbol flags}], Ret: {\"*\" {:poly/type clobits.all_targets.IVoidPointerYE, :ni/type clobits.all_targets.IVoidPointer, :ni/wrapper {:convert clobits.wrappers.WrapVoid}, :ni/unwrap .unwrap, :poly/wrapper {:convert wrap-pointer}, :poly/unwrap .unwrap, :primitive false}, :poly/type clobits.all_targets.IVoidPointerYE, :ni/type clobits.all_targets.IVoidPointer, :ni/wrapper {:convert clobits.wrappers.WrapVoid}, :ni/unwrap .unwrap, :poly/wrapper {:convert wrap-pointer}, :poly/unwrap .unwrap, :primitive false}"
 ^clobits.all_targets.IVoidPointerYE
 [title ^Long x ^Long y ^Long w ^Long h ^Long flags]
 (clojure.core/->
  (.execute
   -place-of-create-window
   (clojure.core/object-array [title x y w h flags]))
  wrap-pointer))

(def
 ^{:private true}
 -place-of-fill-rect
 (.getMember polyglot-lib "_SHADOWING_SDL_FillRect"))

(clojure.core/defn
 fill-rect
 "Args:[{:interface bindings.sdl_structs.ISDL_Surface, :c-sym \"SDL_Surface\", :ni/interface bindings.sdl.ni.ISDL_Surface, :ni/wrapper {:convert bindings.sdl.ni.SDL_Surface., :type bindings.sdl.ni.SDL_Surface}, :poly/type bindings.sdl_structs.ISDL_Surface, :poly/unwrap .unwrap, :primitive false, :arg-symbol dst, :poly/wrapper {:convert wrap-sdl-surface}, :annotation bindings.sdl_structs.ISDL_Surface, :ni/unwrap .unwrap} {:interface bindings.sdl_structs.ISDL_Rect, :c-sym \"SDL_Rect\", :ni/interface bindings.sdl.ni.ISDL_Rect, :ni/wrapper {:convert bindings.sdl.ni.SDL_Rect., :type bindings.sdl.ni.SDL_Rect}, :poly/type bindings.sdl_structs.ISDL_Rect, :poly/unwrap .unwrap, :primitive false, :arg-symbol rect, :poly/wrapper {:convert wrap-sdl-rect}, :annotation bindings.sdl_structs.ISDL_Rect, :ni/unwrap .unwrap} {:ni/wrapper {:type int, :convert int}, :poly/wrapper {:convert .asInt}, :poly/type int, :primitive true, :annotation long, :arg-symbol color}], Ret: {:ni/wrapper {:type int, :convert int}, :poly/wrapper {:convert .asInt}, :poly/type int, :primitive true}"
 ^long
 [^bindings.sdl_structs.ISDL_Surface
  dst
  ^bindings.sdl_structs.ISDL_Rect
  rect
  ^long
  color]
 (clojure.core/->
  (.execute
   -place-of-fill-rect
   (clojure.core/object-array [(.unwrap dst) (.unwrap rect) color]))
  .asInt))

(def
 ^{:private true}
 -place-of-quit
 (.getMember polyglot-lib "_SHADOWING_SDL_Quit"))

(clojure.core/defn
 quit
 "Args:[], Ret: {\"*\" {:poly/type clobits.all_targets.IVoidPointerYE, :ni/type clobits.all_targets.IVoidPointer, :ni/wrapper {:convert clobits.wrappers.WrapVoid}, :ni/unwrap .unwrap, :poly/wrapper {:convert wrap-pointer}, :poly/unwrap .unwrap, :primitive false}, :ni/type void, :primitive true}"
 
 []
 (.executeVoid -place-of-quit (clojure.core/object-array [])))

