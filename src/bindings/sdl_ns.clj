;; This file is autogenerated -- probably shouldn't modify it by hand
(clojure.core/ns
 bindings.sdl-ns
 (:require [clojure.java.io])
 (:import
  org.graalvm.polyglot.Context
  org.graalvm.polyglot.Source
  org.graalvm.polyglot.Value)
 (:gen-class))

(def ^{:private true} empty-array (clojure.core/object-array 0))

(clojure.core/defn
 context-f538
 []
 (clojure.core/->
  (org.graalvm.polyglot.Context/newBuilder
   (clojure.core/into-array ["llvm"]))
  (.allowAllAccess true)
  (.build)))

(clojure.core/defn
 ^{:private true}
 source-f539
 []
 (clojure.core/->
  (org.graalvm.polyglot.Source/newBuilder
   "llvm"
   (if
    (clojure.core/string? "libs/libbindings$sdl.so")
    (clojure.java.io/file "libs/libbindings$sdl.so")
    "libs/libbindings$sdl.so"))
  (.build)))

(def polyglot-context (context-f538))

(def polyglot-lib (.eval polyglot-context (source-f539)))

(clojure.core/gen-interface
 :name
 ^{org.graalvm.polyglot.HostAccess$Implementable true}
 bindings.sdl_structs.ISDL_Event
 :methods
 [[type [] int]
  [set_type [int] void]
  [key [] bindings.sdl_structs.ISDL_KeyboardEvent]
  [set_key [bindings.sdl_structs.ISDL_KeyboardEvent] void]])

(clojure.core/gen-interface
 :name
 ^{org.graalvm.polyglot.HostAccess$Implementable true}
 bindings.sdl_structs.ISDL_KeyboardEvent
 :methods
 [[keysym [] bindings.sdl_structs.ISDL_Keysym]
  [set_keysym [bindings.sdl_structs.ISDL_Keysym] void]])

(clojure.core/gen-interface
 :name
 ^{org.graalvm.polyglot.HostAccess$Implementable true}
 bindings.sdl_structs.ISDL_Keysym
 :methods
 [[sym [] int] [set_sym [int] void]])

(clojure.core/gen-interface
 :name
 ^{org.graalvm.polyglot.HostAccess$Implementable true}
 bindings.sdl_structs.ISDL_Surface
 :methods
 [[format [] bindings.sdl_structs.ISDL_PixelFormat]
  [set_format [bindings.sdl_structs.ISDL_PixelFormat] void]])

(clojure.core/gen-interface
 :name
 ^{org.graalvm.polyglot.HostAccess$Implementable true}
 bindings.sdl_structs.ISDL_PixelFormat
 :methods
 [[palette [] clobits.all_targets.IVoidPointerYE]
  [set_palette [clobits.all_targets.IVoidPointerYE] void]])

(clojure.core/gen-interface
 :name
 ^{org.graalvm.polyglot.HostAccess$Implementable true}
 bindings.sdl_structs.ISDL_Rect
 :methods
 [[x [] int]
  [set_x [int] void]
  [y [] int]
  [set_y [int] void]
  [w [] int]
  [set_w [int] void]
  [h [] int]
  [set_h [int] void]])

(clojure.core/declare
 wrap-sdl-event
 wrap-sdl-rect
 wrap-pointer
 wrap-sdl-pixel-format
 wrap-sdl-surface
 wrap-sdl-keysym
 wrap-sdl-keyboard-event)

(clojure.core/defn
 wrap-sdl-event
 [value]
 (clojure.core/reify
  bindings.sdl_structs.ISDL_Event
  (type [_] (clojure.core/-> (.getMember value "type") .asInt))
  (set_type [_ v] (.putMember value "type" v))
  (key [_] (wrap-sdl-keyboard-event (.getMember value "key")))
  (set_key [_ v] (.putMember value "key" (.unwrap v)))
  clobits.all_targets.IWrapper
  (unwrap [_] (.as value bindings.sdl_structs.ISDL_Event))))

(clojure.core/defn
 wrap-sdl-keyboard-event
 [value]
 (clojure.core/reify
  bindings.sdl_structs.ISDL_KeyboardEvent
  (keysym [_] (wrap-sdl-keysym (.getMember value "keysym")))
  (set_keysym [_ v] (.putMember value "keysym" (.unwrap v)))
  clobits.all_targets.IWrapper
  (unwrap [_] (.as value bindings.sdl_structs.ISDL_KeyboardEvent))))

(clojure.core/defn
 wrap-sdl-keysym
 [value]
 (clojure.core/reify
  bindings.sdl_structs.ISDL_Keysym
  (sym [_] (clojure.core/-> (.getMember value "sym") .asInt))
  (set_sym [_ v] (.putMember value "sym" v))
  clobits.all_targets.IWrapper
  (unwrap [_] (.as value bindings.sdl_structs.ISDL_Keysym))))

(clojure.core/defn
 wrap-sdl-surface
 [value]
 (clojure.core/reify
  bindings.sdl_structs.ISDL_Surface
  (format [_] (wrap-sdl-pixel-format (.getMember value "format")))
  (set_format [_ v] (.putMember value "format" (.unwrap v)))
  clobits.all_targets.IWrapper
  (unwrap [_] (.as value bindings.sdl_structs.ISDL_Surface))))

(clojure.core/defn
 wrap-sdl-pixel-format
 [value]
 (clojure.core/reify
  bindings.sdl_structs.ISDL_PixelFormat
  (palette [_] (wrap-pointer (.getMember value "palette")))
  (set_palette [_ v] (.putMember value "palette" (.unwrap v)))
  clobits.all_targets.IWrapper
  (unwrap [_] (.as value bindings.sdl_structs.ISDL_PixelFormat))))

(clojure.core/defn
 wrap-sdl-rect
 [value]
 (clojure.core/reify
  bindings.sdl_structs.ISDL_Rect
  (x [_] (clojure.core/-> (.getMember value "x") .asInt))
  (set_x [_ v] (.putMember value "x" v))
  (y [_] (clojure.core/-> (.getMember value "y") .asInt))
  (set_y [_ v] (.putMember value "y" v))
  (w [_] (clojure.core/-> (.getMember value "w") .asInt))
  (set_w [_ v] (.putMember value "w" v))
  (h [_] (clojure.core/-> (.getMember value "h") .asInt))
  (set_h [_ v] (.putMember value "h" v))
  clobits.all_targets.IWrapper
  (unwrap [_] (.as value bindings.sdl_structs.ISDL_Rect))))

(clojure.core/defn
 wrap-pointer
 [value]
 (clojure.core/reify clobits.all_targets.IWrapper (unwrap [_] value)))

(def
 ^{:private true}
 -place-of-get-sdl-init-video
 (.getMember polyglot-lib "_SHADOWING_GET_SDL_INIT_VIDEO"))

(clojure.core/defn
 get-sdl-init-video
 "Ret: {:wrapper nil, :annotation long}"
 ^long
 []
 (clojure.core/->
  (.execute
   -place-of-get-sdl-init-video
   (clojure.core/object-array []))
  .asInt))

(def
 ^{:private true}
 -place-of-get-sdl-window-shown
 (.getMember polyglot-lib "_SHADOWING_GET_SDL_WINDOW_SHOWN"))

(clojure.core/defn
 get-sdl-window-shown
 "Ret: {:wrapper nil, :annotation long}"
 ^long
 []
 (clojure.core/->
  (.execute
   -place-of-get-sdl-window-shown
   (clojure.core/object-array []))
  .asInt))

(def
 ^{:private true}
 -place-of-get-null
 (.getMember polyglot-lib "_SHADOWING_get_null"))

(clojure.core/defn
 get-null
 "Ret: {:wrapper wrap-pointer, :annotation nil}"
 
 []
 (wrap-pointer
  (.executeVoid -place-of-get-null (clojure.core/object-array []))))

(def
 ^{:private true}
 -place-of-gen-title
 (.getMember polyglot-lib "_SHADOWING_gen_title"))

(clojure.core/defn
 gen-title
 "Ret: {:wrapper wrap-pointer, :annotation nil}"
 
 []
 (wrap-pointer
  (.execute -place-of-gen-title (clojure.core/object-array []))))

(def
 ^{:private true}
 -place-of-create-rect
 (.getMember polyglot-lib "_SHADOWING_create_rect"))

(clojure.core/defn
 create-rect
 "Ret: {:wrapper wrap-sdl-rect, :annotation nil}"
 
 [^long x ^long y ^long w ^long h]
 (wrap-sdl-rect
  (.execute
   -place-of-create-rect
   (clojure.core/object-array [(int x) (int y) (int w) (int h)]))))

(def
 ^{:private true}
 -place-of-get-e
 (.getMember polyglot-lib "_SHADOWING_get_e"))

(clojure.core/defn
 get-e
 "Ret: {:wrapper wrap-sdl-event, :annotation nil}"
 
 []
 (wrap-sdl-event
  (.execute -place-of-get-e (clojure.core/object-array []))))

(def
 ^{:private true}
 -place-of-init
 (.getMember polyglot-lib "_SHADOWING_SDL_Init"))

(clojure.core/defn
 init
 "Ret: {:wrapper nil, :annotation long}"
 ^long
 [^long flags]
 (clojure.core/->
  (.execute -place-of-init (clojure.core/object-array [(int flags)]))
  .asInt))

(def
 ^{:private true}
 -place-of-poll-event
 (.getMember polyglot-lib "_SHADOWING_SDL_PollEvent"))

(clojure.core/defn
 poll-event
 "Ret: {:wrapper nil, :annotation long}"
 ^long
 [^clobits.all_targets.IWrapper event]
 (clojure.core/->
  (.execute
   -place-of-poll-event
   (clojure.core/object-array [(.unwrap event)]))
  .asInt))

(def
 ^{:private true}
 -place-of-delay
 (.getMember polyglot-lib "_SHADOWING_SDL_Delay"))

(clojure.core/defn
 delay
 "Ret: {:wrapper nil, :annotation nil}"
 
 [^long ms]
 (.executeVoid -place-of-delay (clojure.core/object-array [(int ms)])))

(def
 ^{:private true}
 -place-of-update-window-surface
 (.getMember polyglot-lib "_SHADOWING_SDL_UpdateWindowSurface"))

(clojure.core/defn
 update-window-surface
 "Ret: {:wrapper nil, :annotation long}"
 ^long
 [^clobits.all_targets.IWrapper window]
 (clojure.core/->
  (.execute
   -place-of-update-window-surface
   (clojure.core/object-array [(.unwrap window)]))
  .asInt))

(def
 ^{:private true}
 -place-of-get-window-surface
 (.getMember polyglot-lib "_SHADOWING_SDL_GetWindowSurface"))

(clojure.core/defn
 get-window-surface
 "Ret: {:wrapper wrap-sdl-surface, :annotation nil}"
 
 [^clobits.all_targets.IWrapper window]
 (wrap-sdl-surface
  (.execute
   -place-of-get-window-surface
   (clojure.core/object-array [(.unwrap window)]))))

(def
 ^{:private true}
 -place-of-map-rgb
 (.getMember polyglot-lib "_SHADOWING_SDL_MapRGB"))

(clojure.core/defn
 map-rgb
 "Ret: {:wrapper nil, :annotation long}"
 ^long
 [^clobits.all_targets.IWrapper format ^long r ^long g ^long b]
 (clojure.core/->
  (.execute
   -place-of-map-rgb
   (clojure.core/object-array
    [(.unwrap format) (int r) (int g) (int b)]))
  .asInt))

(def
 ^{:private true}
 -place-of-create-window
 (.getMember polyglot-lib "_SHADOWING_SDL_CreateWindow"))

(clojure.core/defn
 create-window
 "Ret: {:wrapper wrap-pointer, :annotation nil}"
 
 [^clobits.all_targets.IWrapper
  title
  ^Long
  x
  ^Long
  y
  ^Long
  w
  ^Long
  h
  ^Long
  flags]
 (wrap-pointer
  (.execute
   -place-of-create-window
   (clojure.core/object-array
    [(.unwrap title) (int x) (int y) (int w) (int h) (int flags)]))))

(def
 ^{:private true}
 -place-of-fill-rect
 (.getMember polyglot-lib "_SHADOWING_SDL_FillRect"))

(clojure.core/defn
 fill-rect
 "Ret: {:wrapper nil, :annotation long}"
 ^long
 [^clobits.all_targets.IWrapper
  dst
  ^clobits.all_targets.IWrapper
  rect
  ^long
  color]
 (clojure.core/->
  (.execute
   -place-of-fill-rect
   (clojure.core/object-array
    [(.unwrap dst) (.unwrap rect) (int color)]))
  .asInt))

(def
 ^{:private true}
 -place-of-quit
 (.getMember polyglot-lib "_SHADOWING_SDL_Quit"))

(clojure.core/defn
 quit
 "Ret: {:wrapper nil, :annotation nil}"
 
 []
 (.executeVoid -place-of-quit (clojure.core/object-array [])))

